# -*- coding: utf-8 -*-
"""Nurhan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZQIdo-Pr40seArPh77fI3hntBhnlK-jl
"""

# ---------- COLLISIONS ----------
def check_boundary_wall_collision(nx, nz):
    wall_thickness = 20
    player_collision_radius = PLAYER_RADIUS * 0.8
    if (nz + player_collision_radius > GRID_SIZE - wall_thickness and abs(nx) <= GRID_SIZE): return True
    if (nz - player_collision_radius < -GRID_SIZE + wall_thickness and abs(nx) <= GRID_SIZE): return True
    if (nx + player_collision_radius > GRID_SIZE - wall_thickness and abs(nz) <= GRID_SIZE): return True
    if (nx - player_collision_radius < -GRID_SIZE + wall_thickness and abs(nz) <= GRID_SIZE): return True
    return False

def check_obstacle_collision(nx, nz):
    px_half = PLAYER_RADIUS * 1.5 / 2
    pz_half = PLAYER_RADIUS * 1.5 / 2
    for ox, oz, w, d, h in obstacles:
        if abs(nx - ox) < w/2 + px_half and abs(nz - oz) < d/2 + pz_half:
            return True
    return False

def check_trap_collisions():
    global current_message, message_display_time, frozen_until, traps
    if time.time() < frozen_until:
        return False
    current_time = time.time()
    for trap in traps:
        if (distance(px, pz, trap['x'], trap['z']) < PLAYER_RADIUS + 20 and trap['active']):
            frozen_until = current_time + 3
            trap['active'] = False
            trap['cooldown'] = current_time + 2
            current_message = "TRAPPED! Frozen for 3 seconds"
            message_display_time = current_time
            return True
    return False

def check_enemy_collision():
    global current_message, message_display_time, frozen_until, lives, enemies, game_over, high_score
    for i, en in enumerate(enemies):
        if distance(px, pz, en['x'], en['z']) < PLAYER_RADIUS + ENEMY_RADIUS:
            attempts = 0
            while attempts < 20:
                new_x, new_z = random_position(200)
                if distance(new_x, new_z, px, pz) > 150:
                    en['x'], en['z'] = new_x, new_z
                    break
                attempts += 1
            angle = random.uniform(0, 2*math.pi)
            en['dx'], en['dz'] = math.cos(angle), math.sin(angle)
            lives -= 1
            if lives <= 0:
                lives = 0
                current_message = "Game Over! Press R to restart"
                message_display_time = time.time()
                # --- Freeze the game: set game_over and capture high_score
                game_over = True
                if score > high_score:
                    high_score = score
            else:
                current_message = f"Hit by Enemy! Lives: {lives}"
                message_display_time = time.time()
            return True
    return False

# ---------- COLLECTION ----------
def update_collection():
    global keys_collected, score, current_message, message_display_time, lives
    for key in keys:
        if not key['collected'] and distance(px, pz, key['x'], key['z']) < PLAYER_RADIUS + KEY_RADIUS:
            key['collected'] = True
            keys_collected += 1
            current_message = f"Key Found! Total: {keys_collected}"
            message_display_time = time.time()

    for tr in treasures:
        if tr['type']=='gold' and not tr.get('opened',False):
            if distance(px, pz, tr['x'], tr['z']) < PLAYER_RADIUS + 20:
                if keys_collected > 0:
                    tr['opened'] = True
                    keys_collected -= 1
                    old_score = score
                    score += TREASURE_POINTS
                    current_message = f"Treasure Opened! +{TREASURE_POINTS} points"
                    message_display_time = time.time()
                    increase_enemy_speed(old_score, score)
                else:
                    current_message = "Need a key to open treasure!"
                    message_display_time = time.time()

    for tr in treasures:
        if tr['type']=='diamond' and not tr.get('collected', False):
            if distance(px, pz, tr['x'], tr['z']) < PLAYER_RADIUS + 25:
                tr['collected'] = True
                old_score = score
                score += DIAMOND_POINTS
                current_message = f"Diamond Found! +{DIAMOND_POINTS} points"
                message_display_time = time.time()
                increase_enemy_speed(old_score, score)

    for heart in hearts:
        if not heart['collected'] and distance(px, pz, heart['x'], heart['z']) < PLAYER_RADIUS + HEART_RADIUS:
            if lives < max_lives:
                heart['collected'] = True
                lives += 1
                current_message = f"Heart Found! Lives: {lives}"
                message_display_time = time.time()
            else:
                heart['collected'] = True
                old_score = score
                score += 10
                current_message = "Max Hearts! +10 points"
                message_display_time = time.time()
                increase_enemy_speed(old_score, score)

def increase_enemy_speed(old_score, new_score):
    old_milestone = old_score // 50
    new_milestone = new_score // 50
    if new_milestone > old_milestone:
        speed_increase = 0.5 * (new_milestone - old_milestone)
        for enemy in enemies:
            enemy['speed'] = min(ENEMY_MAX_SPEED, enemy['speed'] + speed_increase)
        global current_message, message_display_time
        current_message += f" - Enemy Speed Increased!"
        message_display_time = time.time()

# ---------- ENEMIES ----------
def update_enemies():
    for en in enemies:
        new_x = en['x'] + en['dx'] * en['speed']
        new_z = en['z'] + en['dz'] * en['speed']
        if check_boundary_wall_collision(new_x, new_z):
            if check_boundary_wall_collision(en['x'] + en['dx'] * en['speed'], en['z']):
                en['dx'] *= -1
            if check_boundary_wall_collision(en['x'], en['z'] + en['dz'] * en['speed']):
                en['dz'] *= -1
            angle_adjust = random.uniform(-0.5, 0.5)
            new_angle = math.atan2(en['dz'], en['dx']) + angle_adjust
            en['dx'] = math.cos(new_angle)
            en['dz'] = math.sin(new_angle)
        else:
            en['x'] = new_x
            en['z'] = new_z
        en['speed'] = min(ENEMY_MAX_SPEED, en['speed'] + ENEMY_SPEED_INCREMENT)

# ---------- TRAP ANIMATION ----------
def update_traps():
    current_time = time.time()
    for trap in traps:
        if not trap['active'] and trap['cooldown'] < current_time:
            valid_position = False
            attempts = 0
            while not valid_position and attempts < 20:
                new_x, new_z = random_position(100)
                player_dist = distance(new_x, new_z, px, pz)
                too_close = False
                for other_trap in traps:
                    if other_trap != trap and other_trap['active']:
                        trap_dist = distance(new_x, new_z, other_trap['x'], other_trap['z'])
                        if trap_dist < 100:
                            too_close = True
                            break
                if player_dist > 150 and not too_close:
                    valid_position = True
                    trap['x'] = new_x
                    trap['z'] = new_z
                attempts += 1
            trap['active'] = True

# ---------- MESSAGES & UI ----------
def display_persistent_ui():
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIN_W, 0, WIN_H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()

    # Score
    glColor3f(1, 1, 0)
    glRasterPos2f(20, WIN_H - 30)
    score_text = f"Score: {score}"
    for ch in score_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # Lives
    glColor3f(1, 0.2, 0.2)
    glRasterPos2f(20, WIN_H - 60)
    lives_text = f"Lives: {lives}/{max_lives}"
    for ch in lives_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # Heart symbols
    heart_spacing = 28
    for i in range(min(lives, 10)):
        x_pos = 20 + (i * heart_spacing)
        y_pos = WIN_H - 90
        glRasterPos2f(x_pos, y_pos)
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord('H'))

    # Keys
    glColor3f(1, 1, 0.3)
    glRasterPos2f(20, WIN_H - 120)
    keys_text = f"Keys: {keys_collected}"
    for ch in keys_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))
    for i in range(keys_collected):
        x_pos = 90 + (i * 20)
        y_pos = WIN_H - 122
        glRasterPos2f(x_pos, y_pos)
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, ord('K'))

    # Controls
    glColor3f(0.8, 0.8, 0.8)
    glRasterPos2f(20, WIN_H - 160)
    controls_text = "Controls: WASD to move, SPACE to pause, R to restart, ESC to quit"
    for ch in controls_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, ord(ch))

    # Timer (uses frozen game_time after game over)
    glColor3f(0.5, 1.0, 0.5)
    glRasterPos2f(WIN_W - 200, WIN_H - 30)
    time_left = max(0, TIME_LIMIT - game_time)
    timer_text = f"Time: {int(time_left)}s"
    for ch in timer_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # Enemy speed info
    if enemies:
        avg_speed = sum(enemy['speed'] for enemy in enemies) / len(enemies)
        glColor3f(1, 0.3, 0.3)
        glRasterPos2f(WIN_W - 200, WIN_H - 60)
        speed_text = f"Enemy Speed: {avg_speed:.1f}"
        for ch in speed_text:
            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, ord(ch))

    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def display_message():
    global current_message, message_display_time
    if current_message and time.time() - message_display_time < 2.5 and not game_over:
        glMatrixMode(GL_PROJECTION)
        glPushMatrix()
        glLoadIdentity()
        gluOrtho2D(0, WIN_W, 0, WIN_H)
        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()

        if "Diamond Found" in current_message:
            glColor3f(0, 1, 1)
        elif "Heart Found" in current_message or "Max Hearts" in current_message:
            glColor3f(1, 0.5, 0.8)
        elif "Game Over" in current_message:
            glColor3f(1, 0, 0)
        elif "Hit by Enemy" in current_message or "TRAPPED" in current_message:
            glColor3f(1, 0.5, 0)
        elif "Key Found" in current_message:
            glColor3f(1, 1, 0)
        elif "Treasure Opened" in current_message:
            glColor3f(1, 0.8, 0)
        else:
            glColor3f(1, 0.6, 0)

        message_x = WIN_W/2 - len(current_message) * 5
        glRasterPos2f(message_x, WIN_H/2 + 50)
        for ch in current_message:
            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

        glPopMatrix()
        glMatrixMode(GL_PROJECTION)
        glPopMatrix()
        glMatrixMode(GL_MODELVIEW)

def display_pause_message():
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIN_W, 0, WIN_H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()

    glColor3f(1, 1, 1)
    pause_text = "GAME PAUSED - Press SPACE / Click HOLD to continue"
    text_x = WIN_W/2 - len(pause_text) * 4
    glRasterPos2f(text_x, WIN_H/2)
    for ch in pause_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def display_game_over_screen():
    global score, high_score

    # --- Update high score when game ends ---
    if score > high_score:
        high_score = score

    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, WIN_W, 0, WIN_H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()

    # --- Background (semi-transparent black box) ---


    # --- Title ---
    glColor3f(1, 0, 0)
    game_over_text = "GAME OVER"
    text_x = WIN_W/2 - len(game_over_text) * 9
    glRasterPos2f(text_x, WIN_H/2 + 70)
    for ch in game_over_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # --- Final Score ---
    glColor3f(1, 1, 0)
    score_text = f"Final Score: {score}"
    text_x = WIN_W/2 - len(score_text) * 9
    glRasterPos2f(text_x, WIN_H/2 + 25)
    for ch in score_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # --- High Score ---
    glColor3f(0, 1, 1)
    high_score_text = f"High Score: {high_score}"
    text_x = WIN_W/2 - len(high_score_text) * 9
    glRasterPos2f(text_x, WIN_H/2 - 15)
    for ch in high_score_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    # --- Instruction ---
    glColor3f(1, 1, 1)
    restart_text = "Press R to play again"
    text_x = WIN_W/2 - len(restart_text) * 9
    glRasterPos2f(text_x, WIN_H/2 - 55)
    for ch in restart_text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)


# ---------- ANIMATION ----------
def update_animations():
    global key_bounce_phase, diamond_spin_angle, diamond_bounce_phase
    if game_over:
        return  # stop animating after game over
    key_bounce_phase += 0.1
    diamond_spin_angle = (diamond_spin_angle + 3) % 360
    diamond_bounce_phase += 0.08